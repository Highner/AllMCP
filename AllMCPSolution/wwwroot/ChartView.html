<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artwork Sales Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }

        .filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            color: #333;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-group select,
        .form-group input {
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 14px;
            background-color: white;
            transition: border-color 0.3s;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #764ba2;
        }

        .form-group select[multiple] {
            min-height: 120px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .chart-container {
            position: relative;
            height: 500px;
            margin-top: 30px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .chart-controls {
            position: absolute;
            top: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .chart-controls.left {
            left: 20px;
        }

        .chart-controls.right {
            right: 20px;
        }

        .btn-scale {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s;
        }

        .btn-scale:hover {
            transform: translateY(-2px);
        }

        .message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            display: none;
        }

        .message.visible {
            display: block;
        }

        .message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .message.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .stat-card {
            padding: 15px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üìä Artwork Sales Analysis</h1>

    <button class="btn btn-secondary" onclick="window.location.href='/'">‚Üê Go to Main Menu</button>
    
    <div class="filters">
        <div class="form-group">
            <label for="artistSelect">Select Artist *</label>
            <select id="artistSelect" required>
                <option value="">-- Select an artist --</option>
            </select>
        </div>

        <div class="form-group">
            <label for="categorySelect">Select Categories (hold Ctrl/Cmd)</label>
            <select id="categorySelect" multiple>
                <option value="">Loading...</option>
            </select>
        </div>

        <div class="form-group">
            <label for="dateFrom">From Date</label>
            <input type="date" id="dateFrom">
        </div>

        <div class="form-group">
            <label for="dateTo">To Date</label>
            <input type="date" id="dateTo">
        </div>
    </div>

    <div class="button-group">
        <button class="btn" id="generateChartBtn" disabled>Generate Chart</button>
        <button class="btn btn-secondary" id="clearBtn">Clear Filters</button>
    </div>

    <div class="message" id="message"></div>

    <div class="stats" id="statsContainer" style="display: none;">
        <div class="stat-card">
            <div class="stat-label">Total Sales</div>
            <div class="stat-value" id="statTotalSales">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Avg Low Estimate</div>
            <div class="stat-value" id="statAvgLow">‚Ç¨0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Avg High Estimate</div>
            <div class="stat-value" id="statAvgHigh">‚Ç¨0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Avg Hammer Price</div>
            <div class="stat-value" id="statAvgHammer">‚Ç¨0</div>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart-controls left" id="scaleToggleY1" style="display: none;">
            <button class="btn-scale" id="toggleY1Scale">Y1: Log</button>
        </div>
        <div class="chart-controls right" id="scaleToggleY2" style="display: none;">
            <button class="btn-scale" id="toggleY2Scale">Y2: Linear</button>
        </div>
        <canvas id="salesChart"></canvas>
    </div>

    <div class="chart-container">
        <canvas id="performanceChart"></canvas>
    </div>

    <div class="chart-container">
        <canvas id="hammerPerAreaChart"></canvas>
    </div>
</div>

<script>
    const artistSelect = document.getElementById('artistSelect');
    const categorySelect = document.getElementById('categorySelect');
    const dateFrom = document.getElementById('dateFrom');
    const dateTo = document.getElementById('dateTo');
    const generateChartBtn = document.getElementById('generateChartBtn');
    const clearBtn = document.getElementById('clearBtn');
    const message = document.getElementById('message');
    const statsContainer = document.getElementById('statsContainer');
    const scaleToggleY1 = document.getElementById('scaleToggleY1');
    const scaleToggleY2 = document.getElementById('scaleToggleY2');
    const toggleY1Scale = document.getElementById('toggleY1Scale');
    const toggleY2Scale = document.getElementById('toggleY2Scale');

    let chartInstance = null;
    let performanceChartInstance = null;
    let hammerPerAreaChartInstance = null;
    let currentY1Scale = 'logarithmic';
    let currentY2Scale = 'linear';

    // Parse URL parameters
    function getUrlParams() {
        const params = new URLSearchParams(window.location.search);
        return {
            artistId: params.get('artistId'),
            categories: params.getAll('categories'),
            dateFrom: params.get('dateFrom'),
            dateTo: params.get('dateTo'),
            y1Scale: params.get('y1Scale') || 'logarithmic',
            y2Scale: params.get('y2Scale') || 'linear',
            hiddenSeries: params.getAll('hiddenSeries')
        };
    }

    // Update URL with current filter values
    function updateUrl() {
        const params = new URLSearchParams();

        if (artistSelect.value) {
            params.set('artistId', artistSelect.value);
        }

        const selectedCategories = Array.from(categorySelect.selectedOptions).map(opt => opt.value);
        selectedCategories.forEach(cat => {
            params.append('categories', cat);
        });

        if (dateFrom.value) {
            params.set('dateFrom', dateFrom.value);
        }

        if (dateTo.value) {
            params.set('dateTo', dateTo.value);
        }

        // Add scale parameters
        params.set('y1Scale', currentY1Scale);
        params.set('y2Scale', currentY2Scale);

        // Add hidden series
        if (chartInstance) {
            chartInstance.data.datasets.forEach((dataset, index) => {
                if (chartInstance.getDatasetMeta(index).hidden) {
                    params.append('hiddenSeries', dataset.label);
                }
            });
        }

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.pushState({}, '', newUrl);
    }

    // Apply URL parameters to form
    function applyUrlParams(urlParams) {
        if (urlParams.artistId) {
            artistSelect.value = urlParams.artistId;
            generateChartBtn.disabled = false;
        }

        if (urlParams.categories && urlParams.categories.length > 0) {
            Array.from(categorySelect.options).forEach(option => {
                if (urlParams.categories.includes(option.value)) {
                    option.selected = true;
                }
            });
        }

        if (urlParams.dateFrom) {
            dateFrom.value = urlParams.dateFrom;
        }

        if (urlParams.dateTo) {
            dateTo.value = urlParams.dateTo;
        }

        // Apply scale parameters
        if (urlParams.y1Scale) {
            currentY1Scale = urlParams.y1Scale;
            toggleY1Scale.textContent = `Y1: ${currentY1Scale === 'logarithmic' ? 'Log' : 'Linear'}`;
        }

        if (urlParams.y2Scale) {
            currentY2Scale = urlParams.y2Scale;
            toggleY2Scale.textContent = `Y2: ${currentY2Scale === 'linear' ? 'Linear' : 'Log'}`;
        }
    }

    // Apply hidden series from URL
    function applyHiddenSeries(hiddenSeries) {
        if (chartInstance && hiddenSeries && hiddenSeries.length > 0) {
            chartInstance.data.datasets.forEach((dataset, index) => {
                if (hiddenSeries.includes(dataset.label)) {
                    chartInstance.getDatasetMeta(index).hidden = true;
                }
            });
            chartInstance.update();
        }
    }

    // Load artists on page load
    async function loadArtists() {
        try {
            const response = await fetch('/api/artists');
            if (response.ok) {
                const artists = await response.json();
                artistSelect.innerHTML = '<option value="">-- Select an artist --</option>';
                artists.forEach(artist => {
                    const option = document.createElement('option');
                    option.value = artist.id;
                    option.textContent = `${artist.firstName} ${artist.lastName}`;
                    artistSelect.appendChild(option);
                });

                // Apply URL params after artists are loaded
                const urlParams = getUrlParams();
                applyUrlParams(urlParams);

                // Auto-generate chart if artist is specified in URL
                if (urlParams.artistId) {
                    await generateChart();
                    // Apply hidden series after chart is rendered
                    applyHiddenSeries(urlParams.hiddenSeries);
                }
            } else {
                showMessage('Failed to load artists', 'error');
            }
        } catch (error) {
            showMessage('Error loading artists: ' + error.message, 'error');
        }
    }

    // Load categories on page load
    async function loadCategories() {
        try {
            const response = await fetch('/api/categories');
            if (response.ok) {
                const categories = await response.json();
                categorySelect.innerHTML = '';
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categorySelect.appendChild(option);
                });

                // Reapply category selections from URL after categories are loaded
                const urlParams = getUrlParams();
                if (urlParams.categories && urlParams.categories.length > 0) {
                    Array.from(categorySelect.options).forEach(option => {
                        if (urlParams.categories.includes(option.value)) {
                            option.selected = true;
                        }
                    });
                }
            } else {
                showMessage('Failed to load categories', 'error');
            }
        } catch (error) {
            showMessage('Error loading categories: ' + error.message, 'error');
        }
    }

    // Set default date range (last year)
    function setDefaultDates() {
        // Only set defaults if no dates are in URL
        const urlParams = getUrlParams();
        if (!urlParams.dateFrom && !urlParams.dateTo) {
            const today = new Date();
            const lastYear = new Date(today);
            lastYear.setFullYear(today.getFullYear() - 1);

            dateTo.valueAsDate = today;
            dateFrom.valueAsDate = lastYear;
        }
    }

    // Enable generate button when artist is selected
    artistSelect.addEventListener('change', () => {
        generateChartBtn.disabled = !artistSelect.value;
        updateUrl();
    });

    // Update URL when categories change
    categorySelect.addEventListener('change', () => {
        updateUrl();
    });

    // Update URL when dates change
    dateFrom.addEventListener('change', () => {
        updateUrl();
    });

    dateTo.addEventListener('change', () => {
        updateUrl();
    });

    // Toggle Y1 scale
    toggleY1Scale.addEventListener('click', () => {
        currentY1Scale = currentY1Scale === 'logarithmic' ? 'linear' : 'logarithmic';
        toggleY1Scale.textContent = `Y1: ${currentY1Scale === 'logarithmic' ? 'Log' : 'Linear'}`;
        if (chartInstance) {
            chartInstance.options.scales.y.type = currentY1Scale;
            chartInstance.update();
        }
        updateUrl();
    });

    // Toggle Y2 scale
    toggleY2Scale.addEventListener('click', () => {
        currentY2Scale = currentY2Scale === 'linear' ? 'logarithmic' : 'linear';
        toggleY2Scale.textContent = `Y2: ${currentY2Scale === 'linear' ? 'Linear' : 'Log'}`;
        if (chartInstance) {
            chartInstance.options.scales.y2.type = currentY2Scale;
            chartInstance.update();
        }
        updateUrl();
    });

    // Clear filters
    clearBtn.addEventListener('click', () => {
        artistSelect.value = '';
        categorySelect.selectedIndex = -1;
        setDefaultDates();
        generateChartBtn.disabled = true;
        if (chartInstance) {
            chartInstance.destroy();
            chartInstance = null;
        }
        if (performanceChartInstance) {
            performanceChartInstance.destroy();
            performanceChartInstance = null;
        }
        if (hammerPerAreaChartInstance) {
            hammerPerAreaChartInstance.destroy();
            hammerPerAreaChartInstance = null;
        }
        statsContainer.style.display = 'none';
        scaleToggleY1.style.display = 'none';
        scaleToggleY2.style.display = 'none';
        message.classList.remove('visible');

        // Reset scales to defaults
        currentY1Scale = 'logarithmic';
        currentY2Scale = 'linear';
        toggleY1Scale.textContent = 'Y1: Log';
        toggleY2Scale.textContent = 'Y2: Linear';

        // Clear URL parameters
        window.history.pushState({}, '', window.location.pathname);
    });

    // Generate chart function (extracted for reuse)
    async function generateChart() {
        if (!artistSelect.value) {
            showMessage('Please select an artist', 'error');
            return;
        }

        const selectedCategories = Array.from(categorySelect.selectedOptions).map(opt => opt.value);

        const params = new URLSearchParams({
            artistId: artistSelect.value,
            dateFrom: dateFrom.value || '',
            dateTo: dateTo.value || ''
        });

        // Add multiple categories
        selectedCategories.forEach(cat => {
            params.append('categories', cat);
        });

        generateChartBtn.disabled = true;
        showMessage('Loading chart data...', 'info');

        try {
            // Fetch all datasets in parallel
            const hammerPerAreaPromise = fetchHammerPerAreaData(
                artistSelect.value,
                selectedCategories,
                dateFrom.value || '',
                dateTo.value || ''
            );

            const [salesResponse, performanceResponse, hammerPerAreaSeries] = await Promise.all([
                fetch(`/api/chart-data?${params}`),
                fetch(`/api/performance-data?${params}`),
                hammerPerAreaPromise
            ]);

            if (!salesResponse.ok || !performanceResponse.ok) {
                throw new Error(`HTTP error! status: ${salesResponse.status}`);
            }

            const salesData = await salesResponse.json();
            const performanceData = await performanceResponse.json();

            if (salesData.sales.length === 0) {
                showMessage('No sales data found for the selected filters', 'info');
                generateChartBtn.disabled = false;
                statsContainer.style.display = 'none';
                return;
            }

            renderChart(salesData.sales);
            renderPerformanceChart(performanceData.timeSeries);
            renderHammerPerAreaChart(hammerPerAreaSeries);
            updateStats(salesData.sales);
            scaleToggleY1.style.display = 'flex';
            scaleToggleY2.style.display = 'flex';
            message.classList.remove('visible');
        } catch (error) {
            showMessage('Error loading chart data: ' + error.message, 'error');
        } finally {
            generateChartBtn.disabled = false;
        }
    }

    // Generate chart
    generateChartBtn.addEventListener('click', async () => {
        updateUrl();
        await generateChart();
    });

    function renderChart(sales) {
        if (chartInstance) {
            chartInstance.destroy();
        }

        // Sort sales by date
        sales.sort((a, b) => new Date(a.saleDate) - new Date(b.saleDate));

        // Group sales by category
        const salesByCategory = sales.reduce((acc, sale) => {
            if (!acc[sale.category]) {
                acc[sale.category] = [];
            }
            acc[sale.category].push(sale);
            return acc;
        }, {});

        const datasets = [];
        const colors = [
            '#667eea', '#ff6b6b', '#51cf66', '#ffd43b', '#748ffc',
            '#ff8787', '#69db7c', '#ffa94d', '#a78bfa', '#f783ac'
        ];
        let colorIndex = 0;

        // Calculate rolling average for each category
        const threeMonthsMs = 90 * 24 * 60 * 60 * 1000;

        // Create datasets for each category
        Object.keys(salesByCategory).forEach(category => {
            const categorySales = salesByCategory[category];
            const color = colors[colorIndex % colors.length];
            colorIndex++;

            // Hammer price points for this category
            datasets.push({
                label: `${category} - Hammer Price`,
                data: categorySales.map(s => ({ x: new Date(s.saleDate), y: s.hammerPrice, sale: s })), 
                borderColor: color,
                backgroundColor: color,
                showLine: false,
                pointRadius: 3,
                pointHoverRadius: 5,
                pointStyle: 'circle'
            });

            // Rolling average for this category
            const rollingAverageData = [];
            for (let i = 0; i < categorySales.length; i++) {
                const currentDate = new Date(categorySales[i].saleDate);
                const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
                const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);

                const windowSales = categorySales.filter(s => {
                    const saleDate = new Date(s.saleDate);
                    return saleDate >= windowStart && saleDate <= windowEnd && (s.sold === true);
                });

                if (windowSales.length > 0) {
                    const avg = windowSales.reduce((sum, s) => sum + s.hammerPrice, 0) / windowSales.length;
                    rollingAverageData.push({
                        x: currentDate,
                        y: avg
                    });
                }
            }

            datasets.push({
                label: `${category} - Rolling Avg`,
                data: rollingAverageData,
                borderColor: color,
                borderWidth: 2,
                pointRadius: 0,
                showLine: true,
                fill: false,
                tension: 0.4,
                borderDash: [5, 5]
            });
        });

        // Add price per area dataset for all sales
        const pricePerAreaData = sales
            .filter(s => s.height && s.width && s.height > 0 && s.width > 0)
            .map(s => ({
                x: new Date(s.saleDate),
                y: s.hammerPrice / (s.height * s.width),
                sold: (s.sold === true),
                sale: s
            }));

        datasets.push({
            label: 'Price per Area (‚Ç¨/cm¬≤)',
            data: pricePerAreaData,
            borderColor: '#e64980',
            backgroundColor: '#e64980',
            showLine: false,
            pointRadius: 3,
            pointHoverRadius: 5,
            pointStyle: 'triangle',
            yAxisID: 'y2'
        });

        // Calculate rolling average for price per area
        const pricePerAreaSorted = [...pricePerAreaData].sort((a, b) => a.x - b.x);
        const pricePerAreaRollingAvg = [];

        for (let i = 0; i < pricePerAreaSorted.length; i++) {
            const currentDate = pricePerAreaSorted[i].x;
            const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
            const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);

            const windowData = pricePerAreaSorted.filter(d => {
                return d.x >= windowStart && d.x <= windowEnd && (d.sold === true);
            });

            if (windowData.length > 0) {
                const avg = windowData.reduce((sum, d) => sum + d.y, 0) / windowData.length;
                pricePerAreaRollingAvg.push({
                    x: currentDate,
                    y: avg
                });
            }
        }

        datasets.push({
            label: 'Price per Area - Rolling Avg',
            data: pricePerAreaRollingAvg,
            borderColor: '#e64980',
            borderWidth: 2,
            pointRadius: 0,
            showLine: true,
            fill: false,
            tension: 0.4,
            borderDash: [5, 5],
            yAxisID: 'y2'
        });

        const ctx = document.getElementById('salesChart').getContext('2d');

        chartInstance = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'nearest',
                    intersect: true,
                    axis: 'xy'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Artwork Sales Price Trends',
                        font: {
                            size: 18
                        }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        onClick: (e, legendItem, legend) => {
                            const index = legendItem.datasetIndex;
                            const ci = legend.chart;
                            const meta = ci.getDatasetMeta(index);

                            meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
                            ci.update();

                            // Update URL when legend item is clicked
                            updateUrl();
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                const isPerArea = context.dataset.yAxisID === 'y2' || (context.dataset.label && context.dataset.label.includes('per Area'));
                                if (isRolling) {
                                    // Keep simple label for rolling averages
                                    return `${context.dataset.label}: ${isPerArea ? '‚Ç¨' + context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '/cm¬≤' : '‚Ç¨' + context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                                }
                                // For point datasets: show the metric only
                                if (isPerArea) {
                                    return `Price per Area: ‚Ç¨${context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}/cm¬≤`;
                                }
                                return `Hammer Price: ‚Ç¨${context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                            },
                            afterLabel: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                if (isRolling) return null;

                                let sale = (context.raw && context.raw.sale) ? context.raw.sale : null;

                                // Fallback for hammer price points if sale is not attached
                                if (!sale && context.dataset.label && context.dataset.label.includes('Hammer Price')) {
                                    const dataIndex = context.dataIndex;
                                    const categoryName = context.dataset.label.replace(' - Hammer Price', '');
                                    const categorySales = salesByCategory[categoryName];
                                    if (categorySales && categorySales[dataIndex]) {
                                        sale = categorySales[dataIndex];
                                    }
                                }

                                if (!sale) return null;

                                const name = sale.name || sale.Title || sale.Name;
                                const category = sale.category || sale.Category;
                                const technique = sale.technique || sale.Technique;
                                const height = sale.height ?? sale.Height;
                                const width = sale.width ?? sale.Width;
                                const dateVal = sale.saleDate || sale.SaleDate || (context.parsed && context.parsed.x);
                                const saleDateStr = dateVal ? new Date(dateVal).toLocaleDateString() : null;
                                const dims = (height != null && width != null && height > 0 && width > 0) ? `${height} √ó ${width} cm` : null;

                                const lines = [];
                                if (name) lines.push(`Title: ${name}`);
                                if (category) lines.push(`Category: ${category}`);
                                if (technique) lines.push(`Technique: ${technique}`);
                                if (dims) lines.push(`Dimensions: ${dims}`);
                                if (saleDateStr) lines.push(`Sale Date: ${saleDateStr}`);
                                return lines;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'month',
                            displayFormats: {
                                month: 'MMM yyyy'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Sale Date'
                        }
                    },
                    y: {
                        type: currentY1Scale,
                        title: {
                            display: true,
                            text: 'Price (‚Ç¨)'
                        },
                        ticks: {
                            callback: function(value) {
                                return '‚Ç¨' + value.toLocaleString();
                            }
                        },
                        position: 'left'
                    },
                    y2: {
                        type: currentY2Scale,
                        title: {
                            display: true,
                            text: 'Price per Area (‚Ç¨/cm¬≤)'
                        },
                        ticks: {
                            callback: function(value) {
                                return '‚Ç¨' + value.toLocaleString();
                            }
                        },
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                }
            }
        });
    }

    function renderPerformanceChart(timeSeries) {
        if (performanceChartInstance) {
            performanceChartInstance.destroy();
        }

        const ctx = document.getElementById('performanceChart').getContext('2d');

        // Sort by date
        timeSeries.sort((a, b) => new Date(a.time) - new Date(b.time));

        // Group by category
        const seriesByCategory = timeSeries.reduce((acc, item) => {
            if (!acc[item.category]) {
                acc[item.category] = [];
            }
            acc[item.category].push(item);
            return acc;
        }, {});

        const datasets = [];
        const colors = [
            '#667eea', '#ff6b6b', '#51cf66', '#ffd43b', '#748ffc',
            '#ff8787', '#69db7c', '#ffa94d', '#a78bfa', '#f783ac'
        ];
        let colorIndex = 0;

        const threeMonthsMs = 90 * 24 * 60 * 60 * 1000;

        // Create estimate range background using all data points
        const estimateRangeData = timeSeries.map(t => ({
            x: new Date(t.time),
            y: 1
        }));

        datasets.push({
            label: 'Estimate Range Background',
            data: estimateRangeData,
            borderColor: 'transparent',
            backgroundColor: 'rgba(200, 200, 200, 0.2)',
            pointRadius: 0,
            showLine: true,
            fill: {
                target: 'origin',
                above: 'rgba(200, 200, 200, 0.2)'
            },
            order: 10
        });

        // Create datasets for each category
        Object.keys(seriesByCategory).forEach(category => {
            const categoryData = seriesByCategory[category];
            const color = colors[colorIndex % colors.length];
            colorIndex++;

            // Performance factor points for this category
            datasets.push({
                label: `${category} - Performance`,
                data: categoryData.map(t => ({
                    x: new Date(t.time),
                    y: t.performanceFactor,
                    sale: t
                })), 
                borderColor: color,
                backgroundColor: color,
                pointRadius: 3,
                pointHoverRadius: 5,
                showLine: false,
                order: 1
            });

            // Rolling average for this category
            const rollingAverageData = [];
            for (let i = 0; i < categoryData.length; i++) {
                const currentDate = new Date(categoryData[i].time);
                const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
                const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);

                const windowData = categoryData.filter(t => {
                    const tDate = new Date(t.time);
                    return tDate >= windowStart && tDate <= windowEnd;
                });

                if (windowData.length > 0) {
                    const avg = windowData.reduce((sum, t) => sum + t.performanceFactor, 0) / windowData.length;
                    rollingAverageData.push({
                        x: currentDate,
                        y: avg
                    });
                }
            }

            datasets.push({
                label: `${category} - Rolling Avg`,
                data: rollingAverageData,
                borderColor: color,
                borderWidth: 2,
                pointRadius: 0,
                showLine: true,
                fill: false,
                tension: 0.4,
                borderDash: [5, 5],
                order: 2
            });
        });

        // Add reference lines
        datasets.push({
            label: 'Within Estimate Range (0-1)',
            data: timeSeries.map(t => ({ x: new Date(t.time), y: 0 })),
            borderColor: '#4CAF50',
            borderWidth: 1,
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false,
            showLine: true,
            order: 3
        });

        datasets.push({
            label: 'High Estimate Threshold (1.0)',
            data: timeSeries.map(t => ({ x: new Date(t.time), y: 1 })),
            borderColor: '#FFC107',
            borderWidth: 1,
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false,
            showLine: true,
            order: 3
        });

        performanceChartInstance = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'nearest',
                    intersect: true,
                    axis: 'xy'
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Sales Performance Relative to Estimates',
                        font: {
                            size: 18
                        }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            filter: function(item) {
                                return item.text !== 'Estimate Range Background';
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                if (isRolling) {
                                    return 'Rolling Avg: ' + context.parsed.y.toFixed(3);
                                }
                                if (context.dataset.label && context.dataset.label.includes('Performance')) {
                                    const value = context.parsed.y;
                                    let interpretation = '';
                                    if (value < 0) interpretation = ' (Below low estimate)';
                                    else if (value <= 1) interpretation = ' (Within estimate range)';
                                    else interpretation = ' (Above high estimate)';
                                    return 'Performance Factor: ' + value.toFixed(3) + interpretation;
                                }
                                return context.dataset.label;
                            },
                            afterLabel: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                if (isRolling) return null;
                                const sale = context.raw && context.raw.sale ? context.raw.sale : null;
                                if (!sale) return null;
                                const name = sale.name || sale.Title || sale.Name;
                                const category = sale.category || sale.Category;
                                const technique = sale.technique || sale.Technique;
                                const height = sale.height ?? sale.Height;
                                const width = sale.width ?? sale.Width;
                                const dateVal = sale.saleDate || sale.SaleDate || sale.time;
                                const saleDateStr = dateVal ? new Date(dateVal).toLocaleDateString() : null;
                                const dims = (height != null && width != null && height > 0 && width > 0) ? `${height} √ó ${width} cm` : null;
                                const lines = [];
                                if (name) lines.push(`Title: ${name}`);
                                if (category) lines.push(`Category: ${category}`);
                                if (technique) lines.push(`Technique: ${technique}`);
                                if (dims) lines.push(`Dimensions: ${dims}`);
                                if (saleDateStr) lines.push(`Sale Date: ${saleDateStr}`);
                                return lines;
                            }
                        },
                        filter: function(tooltipItem) {
                            return tooltipItem.dataset.label &&
                                (tooltipItem.dataset.label.includes('Performance') ||
                                    tooltipItem.dataset.label.includes('Rolling Avg'));
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'month',
                            displayFormats: {
                                month: 'MMM yyyy'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Sale Date'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Performance Factor'
                        },
                        ticks: {
                            callback: function(value) {
                                return value.toFixed(2);
                            }
                        }
                    }
                }
            }
        });
    }

    function updateStats(sales) {
        const totalSales = sales.length;
        const avgLow = sales.reduce((sum, s) => sum + s.lowEstimate, 0) / totalSales;
        const avgHigh = sales.reduce((sum, s) => sum + s.highEstimate, 0) / totalSales;
        const avgHammer = sales.reduce((sum, s) => sum + s.hammerPrice, 0) / totalSales;

        document.getElementById('statTotalSales').textContent = totalSales;
        document.getElementById('statAvgLow').textContent = '‚Ç¨' + avgLow.toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        document.getElementById('statAvgHigh').textContent = '‚Ç¨' + avgHigh.toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        document.getElementById('statAvgHammer').textContent = '‚Ç¨' + avgHammer.toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });

        statsContainer.style.display = 'grid';
    }

    function showMessage(text, type) {
        message.textContent = text;
        message.className = 'message visible ' + type;
    }

    // Initialize
    loadArtists();
    loadCategories();
    setDefaultDates();

    // Fetch hammer price per area data from the new controller
    async function fetchHammerPerAreaData(artistId, categories, dateFromVal, dateToVal) {
        const merged = [];
        const selected = (categories && categories.length > 0) ? categories : [null];

        async function fetchForCategory(category) {
            let page = 1;
            let safetyCounter = 0; // prevent infinite loops
            const maxPages = 5; // hard cap to avoid excessive network calls

            while (true) {
                const params = new URLSearchParams();
                if (artistId) params.set('artistId', artistId);
                if (dateFromVal) params.set('saleDateFrom', dateFromVal);
                if (dateToVal) params.set('saleDateTo', dateToVal);
                if (category) params.set('category', category);
                params.set('page', String(page));

                const res = await fetch(`/api/hammer-per-area?${params.toString()}`);
                if (!res.ok) throw new Error(`HammerPerArea HTTP ${res.status}`);
                const json = await res.json();

                if (json && Array.isArray(json.timeSeries)) {
                    merged.push(...json.timeSeries);
                }

                const hasMore = json && json.hasMoreResults === true;
                page += 1;
                safetyCounter += 1;
                if (!hasMore || safetyCounter >= maxPages) {
                    break;
                }
            }
        }

        for (const cat of selected) {
            await fetchForCategory(cat);
        }

        return merged;
    }

    // Render the hammer price per area chart
    function renderHammerPerAreaChart(series) {
        if (hammerPerAreaChartInstance) {
            hammerPerAreaChartInstance.destroy();
        }

        const ctx = document.getElementById('hammerPerAreaChart').getContext('2d');
        // sort by time
        series.sort((a, b) => new Date(a.time) - new Date(b.time));

        const perArea = series
            .filter(p => p.hammerPricePerArea != null)
            .map(p => ({
                x: new Date(p.time),
                y: p.hammerPricePerArea,
                sold: (p.sold ?? p.Sold ?? null),
                sale: {
                    name: p.title || p.Name || p.name,
                    category: p.category || p.Category,
                    technique: p.technique || p.Technique,
                    height: p.height ?? p.Height,
                    width: p.width ?? p.Width,
                    saleDate: p.time || p.SaleDate,
                    hammerPrice: p.hammerPrice ?? p.HammerPrice
                }
            }));
        const perAreaAdj = series
            .filter(p => p.hammerPricePerAreaInflationAdjusted != null)
            .map(p => ({
                x: new Date(p.time),
                y: p.hammerPricePerAreaInflationAdjusted,
                sold: (p.sold ?? p.Sold ?? null),
                sale: {
                    name: p.title || p.Name || p.name,
                    category: p.category || p.Category,
                    technique: p.technique || p.Technique,
                    height: p.height ?? p.Height,
                    width: p.width ?? p.Width,
                    saleDate: p.time || p.SaleDate,
                    hammerPrice: p.hammerPrice ?? p.HammerPrice
                }
            }));

        const threeMonthsMs = 90 * 24 * 60 * 60 * 1000;

        // Calculate rolling average for hammer price per area
        const perAreaRollingAvg = [];
        for (let i = 0; i < perArea.length; i++) {
            const currentDate = perArea[i].x;
            const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
            const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);

            const windowData = perArea.filter(d => {
                return d.x >= windowStart && d.x <= windowEnd && (d.sold === true);
            });

            if (windowData.length > 0) {
                const avg = windowData.reduce((sum, d) => sum + d.y, 0) / windowData.length;
                perAreaRollingAvg.push({
                    x: currentDate,
                    y: avg
                });
            }
        }

        // Calculate rolling average for inflation-adjusted per area
        const perAreaAdjRollingAvg = [];
        for (let i = 0; i < perAreaAdj.length; i++) {
            const currentDate = perAreaAdj[i].x;
            const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
            const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);

            const windowData = perAreaAdj.filter(d => {
                return d.x >= windowStart && d.x <= windowEnd && (d.sold === true);
            });

            if (windowData.length > 0) {
                const avg = windowData.reduce((sum, d) => sum + d.y, 0) / windowData.length;
                perAreaAdjRollingAvg.push({
                    x: currentDate,
                    y: avg
                });
            }
        }

        hammerPerAreaChartInstance = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [
                    {
                        label: 'Hammer Price per Area (‚Ç¨/cm¬≤)',
                        data: perArea,
                        borderColor: '#667eea',
                        backgroundColor: '#667eea',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        showLine: false,
                        order: 1
                    },
                    {
                        label: 'Hammer Price per Area - Rolling Avg',
                        data: perAreaRollingAvg,
                        borderColor: '#667eea',
                        borderWidth: 2,
                        pointRadius: 0,
                        showLine: true,
                        fill: false,
                        tension: 0.4,
                        borderDash: [5, 5],
                        order: 2
                    },
                    {
                        label: 'Inflation-Adjusted per Area (‚Ç¨/cm¬≤)',
                        data: perAreaAdj,
                        borderColor: '#51cf66',
                        backgroundColor: '#51cf66',
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        showLine: false,
                        order: 1
                    },
                    {
                        label: 'Inflation-Adjusted - Rolling Avg',
                        data: perAreaAdjRollingAvg,
                        borderColor: '#51cf66',
                        borderWidth: 2,
                        pointRadius: 0,
                        showLine: true,
                        fill: false,
                        tension: 0.4,
                        borderDash: [5, 5],
                        order: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Hammer Price per Area (with Inflation-Adjusted)',
                        font: { size: 18 }
                    },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                const val = context.parsed.y;
                                if (isRolling) {
                                    return `${context.dataset.label}: ‚Ç¨${val.toLocaleString(undefined, { maximumFractionDigits: 2 })}/cm¬≤`;
                                }
                                if (context.dataset.label && context.dataset.label.includes('Inflation-Adjusted')) {
                                    return `Price per Area (Adj): ‚Ç¨${val.toLocaleString(undefined, { maximumFractionDigits: 2 })}/cm¬≤`;
                                }
                                return `Price per Area: ‚Ç¨${val.toLocaleString(undefined, { maximumFractionDigits: 2 })}/cm¬≤`;
                            },
                            afterLabel: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                if (isRolling) return null;
                                const sale = context.raw && context.raw.sale ? context.raw.sale : null;
                                if (!sale) return null;
                                const name = sale.name || sale.Title || sale.Name;
                                const category = sale.category || sale.Category;
                                const technique = sale.technique || sale.Technique;
                                const height = sale.height ?? sale.Height;
                                const width = sale.width ?? sale.Width;
                                const saleDateStr = sale.saleDate ? new Date(sale.saleDate).toLocaleDateString() : (sale.SaleDate ? new Date(sale.SaleDate).toLocaleDateString() : null);
                                const dims = (height != null && width != null && height > 0 && width > 0) ? `${height} √ó ${width} cm` : null;
                                const lines = [];
                                if (name) lines.push(`Title: ${name}`);
                                if (category) lines.push(`Category: ${category}`);
                                if (technique) lines.push(`Technique: ${technique}`);
                                if (dims) lines.push(`Dimensions: ${dims}`);
                                if (saleDateStr) lines.push(`Sale Date: ${saleDateStr}`);
                                return lines;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'month',
                            displayFormats: {
                                month: 'MMM yyyy'
                            }
                        },
                        title: { display: true, text: 'Sale Date' }
                    },
                    y: {
                        type: 'linear',
                        title: { display: true, text: '‚Ç¨ per cm¬≤' },
                        ticks: {
                            callback: function(value) {
                                return '‚Ç¨' + Number(value).toLocaleString();
                            }
                        }
                    }
                }
            }
        });
    }
</script>
</body>
</html>
