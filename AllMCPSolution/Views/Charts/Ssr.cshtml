@model AllMCPSolution.Controllers.ChartSsrViewModel
@using System.Text.Json
@{
    Layout = null;
    var jsonOptions = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
    var salesJson = JsonSerializer.Serialize(Model.Sales, jsonOptions);
    var perfJson = JsonSerializer.Serialize(Model.Performance, jsonOptions);
    var hpaJson = JsonSerializer.Serialize(Model.HammerPerArea, jsonOptions);
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artwork Sales Analysis (SSR)</title>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="stylesheet" href="/css/wine-surfer-theme.css" />
    <style>
        /* Styles copied to match charts section of ChartView.html */
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 18px;
            box-shadow: 0 18px 60px rgba(0, 0, 0, 0.45);
        }
        .chart-controls {
            position: absolute;
            top: 10px;
            display: flex;
            gap: 8px;
            z-index: 2;
        }
        .chart-controls.left { left: 10px; }
        .chart-controls.right { right: 10px; }
        .btn-scale {
            background: linear-gradient(135deg, rgba(244, 241, 234, 0.28) 0%, rgba(244, 241, 234, 0.14) 100%);
            color: #050505;
            border: 1px solid rgba(244, 241, 234, 0.28);
            padding: 6px 12px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
        }
        body { background: var(--wine-app-background); margin: 0; padding: 20px; color: #f4f1ea; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    </style>
</head>
<body class="wine-app">
    <div class="chart-container wine-surface wine-surface-border wine-card-hover">
        <div class="chart-controls left" id="scaleToggleY1">
            <button class="btn-scale" id="toggleY1Scale">Y1: Log</button>
        </div>
        <div class="chart-controls right" id="scaleToggleY2">
            <button class="btn-scale" id="toggleY2Scale">Y2: Linear</button>
        </div>
        <canvas id="salesChart"></canvas>
    </div>

    <div class="chart-container wine-surface wine-surface-border wine-card-hover">
        <canvas id="performanceChart"></canvas>
    </div>

    <div class="chart-container wine-surface wine-surface-border wine-card-hover">
        <canvas id="hammerPerAreaChart"></canvas>
    </div>

<script>
    // Server-provided data
    const sales = @Html.Raw(salesJson);
    const performance = @Html.Raw(perfJson);
    const hammerPerArea = @Html.Raw(hpaJson);

    // Initial scales from URL/model
    let currentY1Scale = '@Model.Y1Scale'.toLowerCase() || 'logarithmic';
    let currentY2Scale = '@Model.Y2Scale'.toLowerCase() || 'linear';

    const toggleY1ScaleBtn = document.getElementById('toggleY1Scale');
    const toggleY2ScaleBtn = document.getElementById('toggleY2Scale');
    const scaleToggleY1 = document.getElementById('scaleToggleY1');
    const scaleToggleY2 = document.getElementById('scaleToggleY2');

    // Update button labels
    toggleY1ScaleBtn.textContent = currentY1Scale === 'logarithmic' ? 'Y1: Log' : 'Y1: Linear';
    toggleY2ScaleBtn.textContent = currentY2Scale === 'logarithmic' ? 'Y2: Log' : 'Y2: Linear';

    let chartInstance = null;
    let performanceChartInstance = null;
    let hammerPerAreaChartInstance = null;

    function renderChart(salesInput) {
        if (chartInstance) chartInstance.destroy();

        // Sort sales by date
        const sales = [...salesInput].sort((a, b) => new Date(a.saleDate) - new Date(b.saleDate));

        // Group sales by category
        const salesByCategory = sales.reduce((acc, sale) => {
            const key = sale.category || 'Unspecified';
            (acc[key] = acc[key] || []).push(sale);
            return acc;
        }, {});

        const datasets = [];
        const colors = [
            '#667eea', '#ff6b6b', '#51cf66', '#ffd43b', '#748ffc',
            '#ff8787', '#69db7c', '#ffa94d', '#a78bfa', '#f783ac'
        ];
        let colorIndex = 0;
        const threeMonthsMs = 90 * 24 * 60 * 60 * 1000;

        Object.keys(salesByCategory).forEach(category => {
            const categorySales = salesByCategory[category];
            const color = colors[colorIndex % colors.length];
            colorIndex++;

            // Hammer Price points
            datasets.push({
                label: `${category} - Hammer Price`,
                data: categorySales.map(s => ({ x: new Date(s.saleDate), y: s.hammerPrice, sale: s })),
                borderColor: color,
                backgroundColor: color,
                showLine: false,
                pointRadius: 3,
                pointHoverRadius: 5,
                pointStyle: 'circle'
            });

            // Rolling average for this category
            const rollingAverageData = [];
            for (let i = 0; i < categorySales.length; i++) {
                const currentDate = new Date(categorySales[i].saleDate);
                const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
                const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);
                const windowSales = categorySales.filter(s => {
                    const d = new Date(s.saleDate);
                    return d >= windowStart && d <= windowEnd;
                });
                if (windowSales.length > 0) {
                    const avg = windowSales.reduce((sum, s) => sum + s.hammerPrice, 0) / windowSales.length;
                    rollingAverageData.push({ x: currentDate, y: avg });
                }
            }
            datasets.push({
                label: `${category} - Rolling Avg`,
                data: rollingAverageData,
                borderColor: color,
                borderWidth: 2,
                pointRadius: 0,
                showLine: true,
                fill: false,
                tension: 0.4,
                borderDash: [5, 5]
            });
        });

        // Price per area (€/cm²) across all sales
        const pricePerAreaData = sales
            .filter(s => s.height && s.width && s.height > 0 && s.width > 0)
            .map(s => ({ x: new Date(s.saleDate), y: s.hammerPrice / (s.height * s.width), sale: s }));
        datasets.push({
            label: 'Price per Area (€/cm²)',
            data: pricePerAreaData,
            borderColor: '#e64980',
            backgroundColor: '#e64980',
            showLine: false,
            pointRadius: 3,
            pointHoverRadius: 5,
            pointStyle: 'triangle',
            yAxisID: 'y2'
        });

        // Rolling average for price per area
        const pricePerAreaSorted = [...pricePerAreaData].sort((a, b) => a.x - b.x);
        const pricePerAreaRollingAvg = [];
        for (let i = 0; i < pricePerAreaSorted.length; i++) {
            const currentDate = pricePerAreaSorted[i].x;
            const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
            const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);
            const windowData = pricePerAreaSorted.filter(d => d.x >= windowStart && d.x <= windowEnd);
            if (windowData.length > 0) {
                const avg = windowData.reduce((sum, d) => sum + d.y, 0) / windowData.length;
                pricePerAreaRollingAvg.push({ x: currentDate, y: avg });
            }
        }
        datasets.push({
            label: 'Price per Area - Rolling Avg',
            data: pricePerAreaRollingAvg,
            borderColor: '#e64980',
            borderWidth: 2,
            pointRadius: 0,
            showLine: true,
            fill: false,
            tension: 0.4,
            borderDash: [5, 5],
            yAxisID: 'y2'
        });

        const ctx = document.getElementById('salesChart').getContext('2d');
        chartInstance = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'nearest', intersect: true, axis: 'xy' },
                plugins: {
                    title: { display: true, text: 'Artwork Sales Price Trends', font: { size: 18 } },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                const isPerArea = context.dataset.yAxisID === 'y2' || (context.dataset.label && context.dataset.label.includes('per Area'));
                                if (isRolling) {
                                    return `${context.dataset.label}: ${isPerArea ? '€' + context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '/cm²' : '€' + context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                                }
                                if (isPerArea) {
                                    return `Price per Area: €${context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}/cm²`;
                                }
                                return `Hammer Price: €${context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                            }
                        }
                    }
                },
                scales: {
                    x: { type: 'time', time: { unit: 'month' } },
                    y: { type: currentY1Scale, title: { display: true, text: 'Hammer Price (€)' }, ticks: { callback: v => '€' + Number(v).toLocaleString() } },
                    y2: { type: currentY2Scale, title: { display: true, text: 'Price per Area (€/cm²)' }, ticks: { callback: v => '€' + Number(v).toLocaleString() }, position: 'right', grid: { drawOnChartArea: false } }
                }
            }
        });
    }

    function renderPerformanceChart(perfItems) {
        if (performanceChartInstance) performanceChartInstance.destroy();

        // Build timeSeries from performance items
        const timeSeries = (perfItems || []).map(p => {
            const mid = (Number(p.lowEstimate || 0) + Number(p.highEstimate || 0)) / 2.0;
            const performanceFactor = mid > 0 ? (Number(p.hammerPrice || 0) / mid) : null;
            return { time: p.saleDate, category: p.category || 'Unspecified', performanceFactor, sale: p };
        }).filter(t => t.performanceFactor != null);

        // Sort and group
        timeSeries.sort((a, b) => new Date(a.time) - new Date(b.time));
        const seriesByCategory = timeSeries.reduce((acc, item) => {
            (acc[item.category] = acc[item.category] || []).push(item);
            return acc;
        }, {});

        const datasets = [];
        const colors = [
            '#667eea', '#ff6b6b', '#51cf66', '#ffd43b', '#748ffc',
            '#ff8787', '#69db7c', '#ffa94d', '#a78bfa', '#f783ac'
        ];
        let colorIndex = 0;
        const threeMonthsMs = 90 * 24 * 60 * 60 * 1000;

        // Estimate range background (flat line at 1 for all points)
        const estimateRangeData = timeSeries.map(t => ({ x: new Date(t.time), y: 1 }));
        datasets.push({
            label: 'Estimate Range Background',
            data: estimateRangeData,
            borderColor: 'transparent',
            backgroundColor: 'rgba(200,200,200,0.2)',
            pointRadius: 0,
            showLine: true,
            fill: { target: 'origin', above: 'rgba(200,200,200,0.2)' },
            order: 10
        });

        Object.keys(seriesByCategory).forEach(category => {
            const categoryData = seriesByCategory[category];
            const color = colors[colorIndex % colors.length];
            colorIndex++;

            // Performance factor points
            datasets.push({
                label: `${category} - Performance`,
                data: categoryData.map(t => ({ x: new Date(t.time), y: t.performanceFactor, sale: t })),
                borderColor: color,
                backgroundColor: color,
                pointRadius: 3,
                pointHoverRadius: 5,
                showLine: false,
                order: 1
            });

            // Rolling average for this category
            const rollingAverageData = [];
            for (let i = 0; i < categoryData.length; i++) {
                const currentDate = new Date(categoryData[i].time);
                const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
                const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);
                const windowData = categoryData.filter(t => {
                    const d = new Date(t.time);
                    return d >= windowStart && d <= windowEnd;
                });
                if (windowData.length > 0) {
                    const avg = windowData.reduce((sum, t) => sum + t.performanceFactor, 0) / windowData.length;
                    rollingAverageData.push({ x: currentDate, y: avg });
                }
            }
            datasets.push({
                label: `${category} - Rolling Avg`,
                data: rollingAverageData,
                borderColor: color,
                borderWidth: 2,
                pointRadius: 0,
                showLine: true,
                fill: false,
                tension: 0.4,
                borderDash: [5, 5]
            });
        });

        const ctx = document.getElementById('performanceChart').getContext('2d');
        performanceChartInstance = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'nearest', intersect: true, axis: 'xy' },
                plugins: {
                    title: { display: true, text: 'Performance vs Estimate', font: { size: 18 } },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                if (isRolling) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}x`;
                                }
                                return `Performance: ${context.parsed.y.toFixed(2)}x`;
                            }
                        }
                    }
                },
                scales: {
                    x: { type: 'time', time: { unit: 'month' } },
                    y: { beginAtZero: true, title: { display: true, text: 'Performance Factor (x)' } }
                }
            }
        });
    }

    function renderHammerPerAreaChart(seriesInput) {
        if (hammerPerAreaChartInstance) hammerPerAreaChartInstance.destroy();

        // Extract possible shapes from server data
        let series = [];
        if (seriesInput && seriesInput.timeSeries) {
            series = seriesInput.timeSeries;
        } else if (Array.isArray(seriesInput)) {
            series = seriesInput;
        }

        // Sort
        series.sort((a, b) => new Date(a.time) - new Date(b.time));

        const perArea = series.filter(p => p.hammerPricePerArea != null).map(p => ({
            x: new Date(p.time),
            y: p.hammerPricePerArea,
            sale: {
                name: p.title || p.name || p.Name,
                category: p.category || p.Category,
                technique: p.technique || p.Technique,
                height: p.height ?? p.Height,
                width: p.width ?? p.Width,
                saleDate: p.time || p.SaleDate,
                hammerPrice: p.hammerPrice ?? p.HammerPrice
            }
        }));
        const perAreaAdj = series.filter(p => p.hammerPricePerAreaInflationAdjusted != null).map(p => ({
            x: new Date(p.time),
            y: p.hammerPricePerAreaInflationAdjusted,
            sale: {
                name: p.title || p.name || p.Name,
                category: p.category || p.Category,
                technique: p.technique || p.Technique,
                height: p.height ?? p.Height,
                width: p.width ?? p.Width,
                saleDate: p.time || p.SaleDate,
                hammerPrice: p.hammerPrice ?? p.HammerPrice
            }
        }));

        const threeMonthsMs = 90 * 24 * 60 * 60 * 1000;
        const perAreaRollingAvg = [];
        for (let i = 0; i < perArea.length; i++) {
            const currentDate = perArea[i].x;
            const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
            const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);
            const windowData = perArea.filter(d => d.x >= windowStart && d.x <= windowEnd);
            if (windowData.length > 0) {
                const avg = windowData.reduce((sum, d) => sum + d.y, 0) / windowData.length;
                perAreaRollingAvg.push({ x: currentDate, y: avg });
            }
        }
        const perAreaAdjRollingAvg = [];
        for (let i = 0; i < perAreaAdj.length; i++) {
            const currentDate = perAreaAdj[i].x;
            const windowStart = new Date(currentDate.getTime() - threeMonthsMs);
            const windowEnd = new Date(currentDate.getTime() + threeMonthsMs);
            const windowData = perAreaAdj.filter(d => d.x >= windowStart && d.x <= windowEnd);
            if (windowData.length > 0) {
                const avg = windowData.reduce((sum, d) => sum + d.y, 0) / windowData.length;
                perAreaAdjRollingAvg.push({ x: currentDate, y: avg });
            }
        }

        const ctx = document.getElementById('hammerPerAreaChart').getContext('2d');
        hammerPerAreaChartInstance = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'Hammer Price per Area (€/cm²)', data: perArea, borderColor: '#667eea', backgroundColor: '#667eea', pointRadius: 3, pointHoverRadius: 5, showLine: false, order: 1 },
                    { label: 'Hammer Price per Area - Rolling Avg', data: perAreaRollingAvg, borderColor: '#667eea', borderWidth: 2, pointRadius: 0, showLine: true, fill: false, tension: 0.4, borderDash: [5,5], order: 2 },
                    { label: 'Inflation-adjusted per Area (€/cm²)', data: perAreaAdj, borderColor: '#e64980', backgroundColor: '#e64980', pointRadius: 3, pointHoverRadius: 5, showLine: false, order: 3 },
                    { label: 'Inflation-adjusted per Area - Rolling Avg', data: perAreaAdjRollingAvg, borderColor: '#e64980', borderWidth: 2, pointRadius: 0, showLine: true, fill: false, tension: 0.4, borderDash: [5,5], order: 4 }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'nearest', intersect: true, axis: 'xy' },
                plugins: {
                    title: { display: true, text: 'Hammer Price per Area Over Time', font: { size: 18 } },
                    legend: { display: true, position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const isRolling = context.dataset.label && context.dataset.label.includes('Rolling Avg');
                                if (isRolling) {
                                    return `${context.dataset.label}: €${context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}/cm²`;
                                }
                                return `€${context.parsed.y.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}/cm²`;
                            }
                        }
                    }
                },
                scales: {
                    x: { type: 'time', time: { unit: 'month' } },
                    y: { type: 'linear', title: { display: true, text: '€/cm²' } }
                }
            }
        });
    }

    // Toggle buttons behavior mirrors ChartView.html
    toggleY1ScaleBtn.addEventListener('click', () => {
        currentY1Scale = currentY1Scale === 'logarithmic' ? 'linear' : 'logarithmic';
        toggleY1ScaleBtn.textContent = currentY1Scale === 'logarithmic' ? 'Y1: Log' : 'Y1: Linear';
        renderChart(sales);
    });
    toggleY2ScaleBtn.addEventListener('click', () => {
        currentY2Scale = currentY2Scale === 'logarithmic' ? 'linear' : 'logarithmic';
        toggleY2ScaleBtn.textContent = currentY2Scale === 'logarithmic' ? 'Y2: Log' : 'Y2: Linear';
        renderChart(sales);
    });

    // Initial render
    scaleToggleY1.style.display = 'flex';
    scaleToggleY2.style.display = 'flex';
    renderChart(sales);
    renderPerformanceChart(performance);
    renderHammerPerAreaChart(hammerPerArea);
</script>
</body>
</html>