@model AllMCPSolution.Controllers.WineSurferTasteProfileViewModel
@using AllMCPSolution.Controllers
@using System.Collections.Generic
@using System.Linq
@using System.Globalization
@using System.Text.Json
@{
    Layout = null;
    var requestPath = Context.Request.Path.HasValue ? Context.Request.Path.Value : string.Empty;
    var requestQuery = Context.Request.QueryString.HasValue ? Context.Request.QueryString.Value : string.Empty;
    var currentLocation = string.Concat(requestPath, requestQuery);
    var topBarModel = (ViewData["WineSurferTopBarModel"] as WineSurferTopBarModel)
        ?? WineSurferTopBarModel.CreateFromSisterhoodData(
            currentLocation,
            Model.IncomingInvitations,
            Model.SentInvitationNotifications,
            displayName: Model.CurrentUser?.DisplayName,
            isAdmin: Model.CurrentUser?.IsAdmin == true);
    var tasteProfileSummary = Model.TasteProfileSummary ?? string.Empty;
    var summaryMaxLength = Model.SummaryMaxLength;
    var tasteProfile = Model.TasteProfile ?? string.Empty;
    var statusMessage = Model.StatusMessage;
    var errorMessage = Model.ErrorMessage;
    var maxLength = Model.MaxLength;
    var suggestedAppellations = Model.SuggestedAppellations ?? Array.Empty<WineSurferSuggestedAppellation>();
    var hasSuggestedAppellations = suggestedAppellations.Count > 0;
    var historyEntries = Model.History ?? Array.Empty<WineSurferTasteProfileHistoryEntry>();
    var hasHistoryEntries = historyEntries.Count > 0;
    var suggestionBudget = Model.CurrentUser?.SuggestionBudget;
    var suggestionBudgetValue = suggestionBudget.HasValue
        ? suggestionBudget.Value.ToString("0.##", CultureInfo.InvariantCulture)
        : string.Empty;
    string? FormatEstimatedPrice(decimal? value)
    {
        if (!value.HasValue)
        {
            return null;
        }

        var normalized = value.Value;
        if (normalized <= 0)
        {
            return null;
        }

        return $"€{normalized.ToString("0.##", CultureInfo.InvariantCulture)}";
    }
    var historyPayload = historyEntries
        .Select(entry => new
        {
            id = entry.Id,
            summary = entry.Summary,
            profile = entry.Profile,
            createdAt = entry.CreatedAtUtc,
            inUse = entry.InUse
        })
        .ToList();
    var historyJson = JsonSerializer.Serialize(historyPayload, new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    });
    var activeHistoryId = Model.ActiveTasteProfileId?.ToString() ?? string.Empty;
    var initialHistoryEntry = historyEntries.FirstOrDefault(entry => entry.InUse) ?? historyEntries.FirstOrDefault();
    var initialHistoryLabel = initialHistoryEntry is null
        ? string.Empty
        : (initialHistoryEntry.InUse ? "In use profile" : "Saved profile");
    ViewData["WineSurferPageTitle"] = "Taste Profile";
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wine Surfer • Taste Profile</title>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#050505" />
    <link rel="stylesheet" href="/css/wine-surfer-theme.css" />
    <link rel="stylesheet" href="/css/wine-surfer-shadcn.css" />
    <link rel="stylesheet" href="/css/wine-surfer-shared-ui.css" />
    <script defer src="/js/pwa.js"></script>
    <style>
        :root {
            color-scheme: dark;
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: var(--wine-app-background);
            color: hsl(var(--foreground));
            font-family: var(--font-sans);
        }

        .taste-profile-main {
            width: min(900px, 100%);
            margin: 0 auto;
            padding: 24px 24px 96px;
            display: flex;
            flex-direction: column;
            gap: 48px;
        }

        .taste-profile-card {
            display: flex;
            flex-direction: column;
            gap: 32px;
            padding: 40px;
            border-radius: calc(var(--radius) * 1.1);
            border: 1px solid hsla(var(--border) / 0.55);
            background: hsla(var(--card) / 0.8);
            box-shadow: 0 32px 80px rgba(0, 0, 0, 0.35);
            --taste-profile-success: 142 69% 58%;
            --taste-profile-success-foreground: 142 76% 90%;
        }

        .taste-profile-header {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .taste-profile-title {
            margin: 0;
            font-size: clamp(32px, 5vw, 52px);
            letter-spacing: 12px;
            text-transform: uppercase;
        }

        .taste-profile-description {
            margin: 0;
            max-width: 48ch;
            color: hsla(var(--muted-foreground) / 0.9);
            font-size: 14px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .taste-profile-banner {
            padding: 16px 20px;
            border-radius: calc(var(--radius) * 0.9);
            border: 1px solid transparent;
            font-size: 13px;
            letter-spacing: 1.8px;
            text-transform: uppercase;
        }

        .taste-profile-banner--success {
            background: hsla(var(--taste-profile-success) / 0.2);
            border-color: hsla(var(--taste-profile-success) / 0.55);
            color: hsl(var(--taste-profile-success-foreground));
        }

        .taste-profile-banner--error {
            background: hsla(var(--destructive) / 0.2);
            border-color: hsla(var(--destructive) / 0.65);
            color: hsl(var(--destructive-foreground));
        }

        .taste-profile-form {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .taste-profile-field {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .taste-profile-input {
            width: 100%;
            max-width: 220px;
            padding: 14px 16px;
            border-radius: calc(var(--radius) * 0.9);
            border: 1px solid hsla(var(--border) / 0.55);
            background: hsla(var(--accent) / 0.12);
            color: inherit;
            font-size: 15px;
            line-height: 1.5;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .taste-profile-input:focus {
            outline: none;
            border-color: hsla(var(--primary) / 0.55);
            box-shadow: 0 0 0 2px hsla(var(--primary) / 0.2);
        }

        .taste-profile-input::-webkit-outer-spin-button,
        .taste-profile-input::-webkit-inner-spin-button {
            margin: 0;
            appearance: none;
        }

        .taste-profile-budget-field .taste-profile-input {
            max-width: 180px;
        }

        .taste-profile-card .taste-profile-label {
            font-size: 16px;
            letter-spacing: 2px;
            text-transform: uppercase;
            padding-bottom: 6px;
            margin: 0;
        }

        /* Ensure the inline summary label has same spacing to its display as form fields (approx 18px) */
        .taste-profile-summary-inline .taste-profile-label {
            padding-bottom: 18px;
        }

        .taste-profile-display {
            width: 100%;
            padding: 18px 20px;
            border-radius: calc(var(--radius) * 1.05);
            border: 1px solid hsla(var(--border) / 0.55);
            background: hsla(var(--accent) / 0.12);
            color: inherit;
            line-height: 1.6;
            font-size: 15px;
            white-space: pre-wrap;
        }

        .taste-profile-display--summary {
            min-height: 56px;
        }

        .taste-profile-display--profile {
            min-height: 220px;
            white-space: normal;
        }

        .taste-profile-display--profile p,
        .taste-profile-display--profile ul,
        .taste-profile-display--profile ol {
            margin: 0 0 0.85em;
        }

        .taste-profile-display--profile ul,
        .taste-profile-display--profile ol {
            padding-left: 1.4em;
        }

        .taste-profile-display--profile li {
            margin-bottom: 0.35em;
        }

        .taste-profile-display--profile strong {
            font-weight: 600;
        }

        .taste-profile-display--profile em {
            font-style: italic;
        }

        .taste-profile-display--profile code {
            padding: 0.1em 0.3em;
            border-radius: calc(var(--radius) * 0.4);
            background: hsla(var(--muted) / 0.2);
            font-size: 0.95em;
            font-family: var(--font-mono, ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
        }

        .taste-profile-display--profile a {
            color: inherit;
            text-decoration: underline;
        }

        .taste-profile-help-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .taste-profile-help {
            margin: 0;
            font-size: 13px;
            color: hsla(var(--muted-foreground) / 0.85);
        }

        .taste-profile-footer {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .taste-profile-meta {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 220px;
        }

        .taste-profile-actions {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }

        .taste-profile-actions .sisterhood-button {
            white-space: nowrap;
        }

        .taste-profile-history-status {
            font-size: 12px;
            letter-spacing: 1.4px;
            text-transform: uppercase;
            color: hsla(var(--muted-foreground) / 0.85);
        }

        .taste-profile-history-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .taste-profile-history-button {
            padding: 0 14px;
            min-width: 44px;
        }

        .taste-profile-suggestions {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .taste-profile-suggestions-header {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        h2.taste-profile-suggestions-title {
            margin: 0;
            font-size: 16px;
            letter-spacing: 2px;
            text-transform: uppercase;
            padding-bottom: 6px;
            font-weight: 400; /* match label styling (non-bold) */
        }

        .taste-profile-suggestions-caption {
            margin: 0;
            font-size: 13px;
            color: hsla(var(--muted-foreground) / 0.8);
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        .taste-profile-suggestions-list {
            margin: 0;
            padding: 0;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .taste-profile-suggestion-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 12px 16px;
            border-radius: calc(var(--radius) * 0.85);
            border: 1px solid hsla(var(--border) / 0.45);
            background: hsla(var(--accent) / 0.12);
        }

        .taste-profile-suggestion-name {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 1.6px;
            text-transform: uppercase;
        }

        .taste-profile-suggestion-location {
            font-size: 13px;
            color: hsla(var(--muted-foreground) / 0.85);
            letter-spacing: 1px;
        }

        .taste-profile-suggestion-reason {
            font-size: 13px;
            color: hsla(var(--muted-foreground) / 0.95);
            letter-spacing: 0.6px;
            line-height: 1.5;
        }

        .taste-profile-suggestion-wines {
            margin: 8px 0 0;
            padding: 0;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .taste-profile-wine-item {
            position: relative;
            padding-left: 18px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .taste-profile-wine-item::before {
            content: "•";
            position: absolute;
            left: 0;
            top: 0;
            color: hsla(var(--muted-foreground) / 0.7);
            font-size: 18px;
            line-height: 1;
        }

        .taste-profile-wine-name {
            font-size: 14px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .taste-profile-wine-details {
            font-size: 12px;
            color: hsla(var(--muted-foreground) / 0.75);
            letter-spacing: 0.8px;
        }

        .taste-profile-wine-price {
            font-size: 12px;
            color: hsla(var(--muted-foreground) / 0.95);
            letter-spacing: 0.8px;
        }

        .taste-profile-suggestions-empty {
            margin: 0;
            font-size: 13px;
            color: hsla(var(--muted-foreground) / 0.85);
            letter-spacing: 1px;
        }

        .taste-profile-generate-button[disabled] {
            cursor: progress;
        }

        .taste-profile-counter {
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: hsla(var(--muted-foreground) / 0.9);
        }

        /* Hidden by default; shown on desktop where it sits above suggestions */
        .taste-profile-summary-inline {
            display: none;
        }

        @@media (max-width: 640px) {
            .taste-profile-card {
                padding: 28px;
            }

            .taste-profile-main {
                padding: 48px 18px 72px;
            }

            .taste-profile-suggestions {
                padding: 20px;
            }

            .taste-profile-suggestion-item {
                padding: 10px 14px;
            }

            .taste-profile-help-row {
                flex-direction: column;
                align-items: stretch;
            }

            .taste-profile-footer {
                flex-direction: column;
                align-items: stretch;
                gap: 20px;
            }

            .taste-profile-actions {
                width: 100%;
                flex-direction: column;
                align-items: stretch;
                gap: 16px;
            }

            .taste-profile-actions .sisterhood-button {
                width: 100%;
            }

            .taste-profile-meta {
                width: 100%;
            }

            .taste-profile-history-controls {
                justify-content: center;
            }
        }
        
        @@media (min-width: 641px) {
            .taste-profile-card {
                padding-top: 28px;
            }
        }
        
        @@media (min-width: 641px) and (max-width: 899px) {
            .taste-profile-card {
                gap: 16px;
            }
        }
        
        @@media (min-width: 900px) {
            .taste-profile-main {
                width: min(1200px, 100%);
            }

            /* Desktop: use CSS Grid to guarantee two columns regardless of DOM order */
            .taste-profile-card {
                display: grid;
                grid-template-columns: minmax(0, 3fr) minmax(0, 2fr);
                grid-auto-flow: dense;
                align-items: start;
                column-gap: 32px;
                row-gap: 16px;
            }

            /* Banners span full width above content */
            .taste-profile-banner,
            #tasteProfileGeneratorMessage {
                grid-column: 1 / -1;
                grid-row: 1;
            }

            /* Main form on the left column */
            .taste-profile-form,
            form.taste-profile-form {
                grid-column: 1;
                grid-row: 2;
                min-width: 0; /* allow content to shrink within grid cell */
            }

            /* Hide the summary field inside the form on desktop to avoid duplication */
            .taste-profile-form .taste-profile-summary-field {
                display: none;
            }

            /* Suggested appellations on the right column */
            .taste-profile-suggestions {
                grid-column: 2;
                grid-row: 2;
                min-width: 0;
            }

            /* Show the inline summary above the suggestions on desktop */
            .taste-profile-suggestions .taste-profile-summary-inline {
                display: block;
                margin-bottom: 12px;
            }
        }
    </style>
</head>
<body class="wine-app wine-app--with-bottom-nav">
    <div class="page-content">
        @await Html.PartialAsync("_WineSurferTopBar", topBarModel)
        <main class="taste-profile-main">
            <section class="taste-profile-card">
                @if (!string.IsNullOrWhiteSpace(statusMessage))
                {
                    <div class="taste-profile-banner taste-profile-banner--success" role="status">@statusMessage</div>
                }
                @if (!string.IsNullOrWhiteSpace(errorMessage))
                {
                    <div class="taste-profile-banner taste-profile-banner--error" role="alert">@errorMessage</div>
                }
                <div id="tasteProfileGeneratorMessage" class="taste-profile-banner" hidden aria-live="polite"></div>
                <section class="taste-profile-suggestions" data-suggested-appellations>
                    <div class="taste-profile-summary-inline">
                        <p class="taste-profile-label">Profile summary</p>
                        <div class="taste-profile-display taste-profile-display--summary" data-summary-inline>@tasteProfileSummary</div>
                    </div>
                    <div class="taste-profile-suggestions-header">
                        <h2 class="taste-profile-suggestions-title">Suggested appellations</h2>
                        <p class="taste-profile-suggestions-caption">Based on your taste profile</p>
                    </div>
                    <ol class="taste-profile-suggestions-list" data-suggested-appellations-list>
                        @foreach (var suggestion in suggestedAppellations)
                        {
                            var hasSub = !string.IsNullOrWhiteSpace(suggestion.SubAppellationName);
                            var primary = hasSub ? suggestion.SubAppellationName : suggestion.AppellationName;
                            if (string.IsNullOrWhiteSpace(primary))
                            {
                                continue;
                            }

                            var wines = suggestion.Wines ?? Array.Empty<WineSurferSuggestedWine>();
                            var hasWines = wines.Count > 0;
                            var detailSegments = new List<string>();
                            if (hasSub && !string.IsNullOrWhiteSpace(suggestion.AppellationName))
                            {
                                detailSegments.Add(suggestion.AppellationName);
                            }

                            var regionCountrySegments = new List<string>();
                            if (!string.IsNullOrWhiteSpace(suggestion.RegionName))
                            {
                                regionCountrySegments.Add(suggestion.RegionName);
                            }

                            if (!string.IsNullOrWhiteSpace(suggestion.CountryName))
                            {
                                regionCountrySegments.Add(suggestion.CountryName);
                            }

                            if (regionCountrySegments.Count > 0)
                            {
                                detailSegments.Add(string.Join(", ", regionCountrySegments));
                            }

                            var detail = detailSegments.Count > 0 ? string.Join(" • ", detailSegments) : null;
                            var reason = string.IsNullOrWhiteSpace(suggestion.Reason)
                                ? null
                                : suggestion.Reason.Trim();

                            <li class="taste-profile-suggestion-item">
                                <span class="taste-profile-suggestion-name">@primary</span>
                                @if (!string.IsNullOrWhiteSpace(detail))
                                {
                                    <span class="taste-profile-suggestion-location">@detail</span>
                                }
                                @if (!string.IsNullOrWhiteSpace(reason))
                                {
                                    <span class="taste-profile-suggestion-reason">@reason</span>
                                }
                                @if (hasWines)
                                {
                                    <ul class="taste-profile-suggestion-wines">
                                        @foreach (var wine in wines)
                                        {
                                            if (wine is null || string.IsNullOrWhiteSpace(wine.Name))
                                            {
                                                continue;
                                            }

                                            var priceText = FormatEstimatedPrice(wine.EstimatedPricePerBottleEur);
                                            var wineDetailsSegments = new List<string>();

                                            if (!string.IsNullOrWhiteSpace(wine.Vintage))
                                            {
                                                wineDetailsSegments.Add(wine.Vintage);
                                            }

                                            if (!string.IsNullOrWhiteSpace(wine.Color))
                                            {
                                                wineDetailsSegments.Add(wine.Color);
                                            }

                                            if (!string.IsNullOrWhiteSpace(wine.Variety))
                                            {
                                                wineDetailsSegments.Add(wine.Variety);
                                            }

                                            if (!string.IsNullOrWhiteSpace(wine.SubAppellationName))
                                            {
                                                wineDetailsSegments.Add(wine.SubAppellationName);
                                            }

                                            var wineDetails = wineDetailsSegments.Count > 0
                                                ? string.Join(" • ", wineDetailsSegments)
                                                : null;

                                            <li class="taste-profile-wine-item">
                                                <span class="taste-profile-wine-name">@wine.Name</span>
                                                @if (!string.IsNullOrWhiteSpace(wineDetails))
                                                {
                                                    <span class="taste-profile-wine-details">@wineDetails</span>
                                                }
                                                @if (!string.IsNullOrWhiteSpace(priceText))
                                                {
                                                    <span class="taste-profile-wine-price">@priceText</span>
                                                }
                                            </li>
                                        }
                                    </ul>
                                }
                            </li>
                        }
                    </ol>
                    <p class="taste-profile-suggestions-empty" data-suggested-appellations-empty @(hasSuggestedAppellations ? "hidden" : null)>
                        Generate your taste profile to see tailored appellation ideas.
                    </p>
                </section>
                <form method="post" action="@Url.Action("UpdateTasteProfile", "TasteProfile")" class="taste-profile-form" novalidate>
                    @Html.AntiForgeryToken()
                    <div class="taste-profile-field taste-profile-budget-field">
                        <p class="taste-profile-label">Suggestion budget</p>
                        <input
                            id="suggestionBudgetInput"
                            name="SuggestionBudget"
                            class="taste-profile-input"
                            type="number"
                            min="0"
                            step="0.01"
                            inputmode="decimal"
                            value="@suggestionBudgetValue"
                            placeholder="e.g. 45" />
                        <p class="taste-profile-help">Tell the assistant the top price per bottle you'd like new recommendations to focus on. Leave blank for no budget.</p>
                    </div>
                    <div class="taste-profile-field taste-profile-summary-field">
                        <p class="taste-profile-label">Profile summary</p>
                        <div class="taste-profile-display taste-profile-display--summary" data-summary-display>@tasteProfileSummary</div>
                        <input
                            id="tasteProfileSummaryInput"
                            name="TasteProfileSummary"
                            type="hidden"
                            data-max-length="@summaryMaxLength"
                            value="@tasteProfileSummary" />
                        <div class="taste-profile-help-row">
                            <p class="taste-profile-help">Share a concise, one-line snapshot of your palate—perfect for recommendations and quick intros.</p>
                            <span class="taste-profile-counter" data-char-count data-for="tasteProfileSummaryInput" data-max-length="@summaryMaxLength">
                                @($"{tasteProfileSummary.Length} / {summaryMaxLength} characters")
                            </span>
                        </div>
                    </div>
                    <div class="taste-profile-field">
                        <p class="taste-profile-label">Your taste profile</p>
                        <div class="taste-profile-display taste-profile-display--profile" data-profile-display>@tasteProfile</div>
                        <textarea
                            id="tasteProfileInput"
                            name="TasteProfile"
                            hidden
                            data-max-length="@maxLength"
                            rows="8">@tasteProfile</textarea>
                        <p class="taste-profile-help">We recommend highlighting grape varieties, favorite producers, and moments you savor. Update it anytime your palate evolves.</p>
                    </div>
                    <div class="taste-profile-footer">
                        <div class="taste-profile-meta">
                            <span class="taste-profile-counter" data-char-count data-for="tasteProfileInput" data-max-length="@maxLength">
                                @($"{tasteProfile.Length} / {maxLength} characters")
                            </span>
                            <span class="taste-profile-history-status" data-history-status @(hasHistoryEntries ? null : "hidden")>
                                @initialHistoryLabel
                            </span>
                        </div>
                        <div class="taste-profile-actions">
                            <div class="taste-profile-history-controls" data-history-controls @(hasHistoryEntries ? null : "hidden")>
                                <button
                                    type="button"
                                    class="wine-surfer-button taste-profile-history-button"
                                    data-history-prev
                                    aria-label="Show previous saved profile">
                                    &lt;
                                </button>
                                <button
                                    type="button"
                                    class="wine-surfer-button taste-profile-history-button"
                                    data-history-next
                                    aria-label="Show next saved profile">
                                    &gt;
                                </button>
                            </div>
                            <button
                                type="button"
                                class="wine-surfer-button wine-surfer-button--orange taste-profile-generate-button"
                                data-generate-taste-profile
                                data-generate-url="@Url.Action("GenerateTasteProfile", "TasteProfile")">
                                Generate profile
                            </button>
                            <button type="submit" class="wine-surfer-button wine-surfer-button--green">Save profile</button>
                        </div>
                    </div>
                    <input type="hidden" name="TasteProfileId" value="@activeHistoryId" data-history-current-id />
                </form>
            </section>
        </main>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js" crossorigin="anonymous"></script>
    <script type="application/json" id="tasteProfileHistoryData">@Html.Raw(historyJson)</script>
    <script>
        (function () {
            const counters = document.querySelectorAll('[data-char-count]');
            if (counters && counters.length > 0) {
                counters.forEach((counter) => {
                    const targetId = counter.getAttribute('data-for');
                    if (!targetId) {
                        return;
                    }

                    const field = document.getElementById(targetId);
                    if (!field) {
                        return;
                    }

                    const maxLength = parseInt(counter.dataset.maxLength || field.getAttribute('maxlength') || '0', 10);
                    const formatCount = (value) => `${value} / ${maxLength} characters`;

                    const updateCount = () => {
                        counter.textContent = formatCount(field.value.length);
                    };

                    field.addEventListener('input', updateCount, { passive: true });
                    updateCount();
                });
            }

            const generatorButton = document.querySelector('[data-generate-taste-profile]');
            if (!generatorButton || typeof window.fetch !== 'function') {
                return;
            }

            const generatorUrl = generatorButton.getAttribute('data-generate-url');
            if (!generatorUrl) {
                return;
            }

            const suggestionBudgetInput = document.getElementById('suggestionBudgetInput');
            const profileField = document.getElementById('tasteProfileInput');
            const summaryField = document.getElementById('tasteProfileSummaryInput');
            if (!profileField || !summaryField) {
                return;
            }

            const summaryDisplay = document.querySelector('[data-summary-display]');
            const profileDisplay = document.querySelector('[data-profile-display]');
            const setDisplayTextContent = (node, value) => {
                if (!node) {
                    return;
                }

                node.textContent = typeof value === 'string' ? value : '';
            };

            const escapeHtml = (value) =>
                typeof value === 'string'
                    ? value
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                    : '';

            const fallbackMarkdown = (value) => escapeHtml(value).replace(/\n/g, '<br />');

            const renderMarkdown = (value) => {
                if (typeof value !== 'string' || !value) {
                    return '';
                }

                if (window.marked && typeof window.marked.parse === 'function') {
                    try {
                        const html = window.marked.parse(value, { breaks: true, gfm: true });
                        if (window.DOMPurify && typeof window.DOMPurify.sanitize === 'function') {
                            return window.DOMPurify.sanitize(html);
                        }

                        return html;
                    } catch (error) {
                        // Ignore parser errors and use the fallback renderer.
                    }
                }

                return fallbackMarkdown(value);
            };

            const updateSummaryDisplay = () => setDisplayTextContent(summaryDisplay, summaryField.value);
            const updateProfileDisplay = () => {
                if (!profileDisplay) {
                    return;
                }

                profileDisplay.innerHTML = renderMarkdown(profileField.value);
            };

            summaryField.addEventListener('input', updateSummaryDisplay, { passive: true });
            profileField.addEventListener('input', updateProfileDisplay, { passive: true });

            updateSummaryDisplay();
            updateProfileDisplay();

            const tokenInput = document.querySelector('input[name="__RequestVerificationToken"]');
            const messageNode = document.getElementById('tasteProfileGeneratorMessage');
            const suggestionsList = document.querySelector('[data-suggested-appellations-list]');
            const suggestionsEmpty = document.querySelector('[data-suggested-appellations-empty]');
            const toText = (value) => (typeof value === 'string' ? value.trim() : '');
            const parsePriceValue = (value) => {
                if (typeof value === 'number' && Number.isFinite(value)) {
                    return value > 0 ? value : null;
                }

                if (typeof value === 'string') {
                    const normalized = value.replace(/[^0-9.,-]/g, '').replace(',', '.');
                    if (normalized) {
                        const parsed = Number.parseFloat(normalized);
                        if (Number.isFinite(parsed) && parsed > 0) {
                            return parsed;
                        }
                    }
                }

                return null;
            };

            const formatPrice = (() => {
                let formatter;
                return (value) => {
                    if (!Number.isFinite(value) || value <= 0) {
                        return '';
                    }

                    if (!formatter) {
                        formatter = new Intl.NumberFormat('en-IE', {
                            style: 'currency',
                            currency: 'EUR',
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 2
                        });
                    }

                    return formatter.format(value);
                };
            })();

            const updateSuggestions = (entries) => {
                if (!suggestionsList || !suggestionsEmpty) {
                    return;
                }

                suggestionsList.innerHTML = '';
                let appended = 0;

                if (Array.isArray(entries)) {
                    const fragment = document.createDocumentFragment();
                    for (const entry of entries) {
                        if (!entry || typeof entry !== 'object') {
                            continue;
                        }

                        const subAppellation = toText(entry.subAppellation);
                        const appellation = toText(entry.appellation);
                        const region = toText(entry.region);
                        const country = toText(entry.country);
                        const reason = toText(entry.reason);
                        const primary = subAppellation || appellation;

                        if (!primary) {
                            continue;
                        }

                        const detailSegments = [];

                        if (subAppellation && appellation) {
                            detailSegments.push(appellation);
                        }

                        const regionCountrySegments = [];
                        if (region) {
                            regionCountrySegments.push(region);
                        }
                        if (country) {
                            regionCountrySegments.push(country);
                        }

                        if (regionCountrySegments.length > 0) {
                            detailSegments.push(regionCountrySegments.join(', '));
                        }

                        const item = document.createElement('li');
                        item.className = 'taste-profile-suggestion-item';

                        const nameNode = document.createElement('span');
                        nameNode.className = 'taste-profile-suggestion-name';
                        nameNode.textContent = primary;
                        item.appendChild(nameNode);

                        if (detailSegments.length > 0) {
                            const locationNode = document.createElement('span');
                            locationNode.className = 'taste-profile-suggestion-location';
                            locationNode.textContent = detailSegments.join(' • ');
                            item.appendChild(locationNode);
                        }

                        if (reason) {
                            const reasonNode = document.createElement('span');
                            reasonNode.className = 'taste-profile-suggestion-reason';
                            reasonNode.textContent = reason;
                            item.appendChild(reasonNode);
                        }

                        const wines = Array.isArray(entry.wines) ? entry.wines : [];
                        if (wines.length > 0) {
                            const winesList = document.createElement('ul');
                            winesList.className = 'taste-profile-suggestion-wines';

                            for (const wine of wines) {
                                if (!wine || typeof wine !== 'object') {
                                    continue;
                                }

                                const wineName = toText(wine.name || wine.Name);
                                if (!wineName) {
                                    continue;
                                }

                                const wineItem = document.createElement('li');
                                wineItem.className = 'taste-profile-wine-item';

                                const wineNameNode = document.createElement('span');
                                wineNameNode.className = 'taste-profile-wine-name';
                                wineNameNode.textContent = wineName;
                                wineItem.appendChild(wineNameNode);

                                const detailSegments = [];
                                const vintageText = toText(wine.vintage || wine.Vintage);
                                if (vintageText) {
                                    detailSegments.push(vintageText);
                                }

                                const colorText = toText(wine.color || wine.Color);
                                if (colorText) {
                                    detailSegments.push(colorText);
                                }

                                const varietyText = toText(wine.variety || wine.Variety);
                                if (varietyText) {
                                    detailSegments.push(varietyText);
                                }

                                const subText = toText(wine.subAppellation || wine.subAppellationName || wine.SubAppellation);
                                if (subText) {
                                    detailSegments.push(subText);
                                }

                                if (detailSegments.length > 0) {
                                    const wineDetailsNode = document.createElement('span');
                                    wineDetailsNode.className = 'taste-profile-wine-details';
                                    wineDetailsNode.textContent = detailSegments.join(' • ');
                                    wineItem.appendChild(wineDetailsNode);
                                }

                                const rawPrice =
                                    wine.estimatedPricePerBottleEur ??
                                    wine.pricePerBottleEur ??
                                    wine.price ??
                                    null;
                                const priceValue = parsePriceValue(rawPrice);
                                if (priceValue !== null) {
                                    const priceNode = document.createElement('span');
                                    priceNode.className = 'taste-profile-wine-price';
                                    priceNode.textContent = formatPrice(priceValue);
                                    wineItem.appendChild(priceNode);
                                }

                                winesList.appendChild(wineItem);
                            }

                            if (winesList.children.length > 0) {
                                item.appendChild(winesList);
                            }
                        }

                        fragment.appendChild(item);
                        appended += 1;
                    }

                    suggestionsList.appendChild(fragment);
                }

                suggestionsEmpty.hidden = appended > 0;
            };

            const setGeneratorMessage = (kind, text) => {
                if (!messageNode) {
                    return;
                }

                messageNode.textContent = text || '';
                messageNode.hidden = !text;
                messageNode.classList.remove('taste-profile-banner--success', 'taste-profile-banner--error');

                if (!text) {
                    messageNode.removeAttribute('role');
                    return;
                }

                if (kind === 'success') {
                    messageNode.classList.add('taste-profile-banner--success');
                    messageNode.setAttribute('role', 'status');
                } else if (kind === 'error') {
                    messageNode.classList.add('taste-profile-banner--error');
                    messageNode.setAttribute('role', 'alert');
                } else {
                    messageNode.removeAttribute('role');
                }
            };

            const dispatchInputEvent = (node) => {
                if (node) {
                    node.dispatchEvent(new Event('input', { bubbles: true }));
                }
            };

            const historyDataElement = document.getElementById('tasteProfileHistoryData');
            const historyPrevButton = document.querySelector('[data-history-prev]');
            const historyNextButton = document.querySelector('[data-history-next]');
            const historyStatusNode = document.querySelector('[data-history-status]');
            const historyControlsNode = document.querySelector('[data-history-controls]');
            const historyIdInput = document.querySelector('[data-history-current-id]');

            let historyEntries = [];
            let historyIndex = -1;

            const normalizeGuid = (value) => (typeof value === 'string' ? value.trim().toLowerCase() : '');

            const parseHistoryEntries = () => {
                historyEntries = [];
                historyIndex = -1;

                if (!historyDataElement) {
                    return;
                }

                try {
                    const raw = historyDataElement.textContent || '[]';
                    const parsed = JSON.parse(raw);
                    if (Array.isArray(parsed)) {
                        historyEntries = parsed
                            .filter((entry) => entry && typeof entry === 'object')
                            .map((entry) => ({
                                id: typeof entry.id === 'string' ? entry.id : (entry.id ? String(entry.id) : ''),
                                summary: typeof entry.summary === 'string' ? entry.summary : '',
                                profile: typeof entry.profile === 'string' ? entry.profile : '',
                                createdAt: typeof entry.createdAt === 'string'
                                    ? entry.createdAt
                                    : (entry.createdAt ? String(entry.createdAt) : ''),
                                inUse: entry.inUse === true
                            }));
                    }
                } catch (error) {
                    historyEntries = [];
                }
            };

            const formatHistoryTimestamp = (isoString) => {
                if (typeof isoString !== 'string' || !isoString) {
                    return '';
                }

                try {
                    const date = new Date(isoString);
                    if (Number.isNaN(date.getTime())) {
                        return '';
                    }

                    if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
                        const formatter = new Intl.DateTimeFormat(undefined, {
                            dateStyle: 'medium',
                            timeStyle: 'short'
                        });
                        return formatter.format(date);
                    }

                    return date.toISOString();
                } catch (error) {
                    return '';
                }
            };

            const updateHistoryStatus = () => {
                if (!historyStatusNode) {
                    return;
                }

                const total = Array.isArray(historyEntries) ? historyEntries.length : 0;
                if (total === 0 || historyIndex < 0 || historyIndex >= total) {
                    historyStatusNode.hidden = true;
                    historyStatusNode.textContent = '';
                    return;
                }

                const entry = historyEntries[historyIndex];
                if (!entry) {
                    historyStatusNode.hidden = true;
                    historyStatusNode.textContent = '';
                    return;
                }

                const prefix = entry.inUse ? 'Viewing in-use profile' : 'Viewing saved profile';
                const timestamp = formatHistoryTimestamp(entry.createdAt);
                historyStatusNode.hidden = false;
                historyStatusNode.textContent = timestamp ? `${prefix} • ${timestamp}` : prefix;
            };

            const updateHistoryButtons = () => {
                const total = Array.isArray(historyEntries) ? historyEntries.length : 0;
                const hasEntries = total > 0;

                if (historyPrevButton) {
                    historyPrevButton.disabled = !hasEntries || historyIndex >= total - 1;
                }

                if (historyNextButton) {
                    historyNextButton.disabled = !hasEntries || historyIndex <= 0;
                }

                if (historyControlsNode) {
                    historyControlsNode.hidden = !hasEntries;
                }
            };

            const showHistoryEntry = (index) => {
                if (!Array.isArray(historyEntries) || historyEntries.length === 0) {
                    return;
                }

                const boundedIndex = Math.max(0, Math.min(index, historyEntries.length - 1));
                const entry = historyEntries[boundedIndex];
                if (!entry) {
                    return;
                }

                historyIndex = boundedIndex;

                if (summaryField) {
                    summaryField.value = entry.summary || '';
                    dispatchInputEvent(summaryField);
                }

                if (profileField) {
                    profileField.value = entry.profile || '';
                    dispatchInputEvent(profileField);
                }

                if (historyIdInput) {
                    historyIdInput.value = entry.id || '';
                }

                updateHistoryButtons();
                updateHistoryStatus();
            };

            const focusEphemeralHistoryEntry = (summary, profile) => {
                const normalizedSummary = typeof summary === 'string' ? summary : (summaryField ? summaryField.value : '');
                const normalizedProfile = typeof profile === 'string' ? profile : (profileField ? profileField.value : '');
                const timestamp = new Date().toISOString();

                const persistedEntries = Array.isArray(historyEntries)
                    ? historyEntries.filter((entry) => entry && entry.id)
                    : [];

                historyEntries = [
                    {
                        id: '',
                        summary: normalizedSummary,
                        profile: normalizedProfile,
                        createdAt: timestamp,
                        inUse: true
                    },
                    ...persistedEntries.map((entry) => ({
                        ...entry,
                        inUse: false
                    }))
                ];

                historyIndex = 0;

                if (historyIdInput) {
                    historyIdInput.value = '';
                }

                updateHistoryButtons();
                updateHistoryStatus();
            };

            const initializeHistory = () => {
                parseHistoryEntries();

                if (!Array.isArray(historyEntries) || historyEntries.length === 0) {
                    if (historyIdInput) {
                        historyIdInput.value = '';
                    }

                    updateHistoryButtons();
                    updateHistoryStatus();
                    return;
                }

                const initialId = historyIdInput && typeof historyIdInput.value === 'string'
                    ? normalizeGuid(historyIdInput.value)
                    : '';

                let initialIndex = -1;

                if (initialId) {
                    initialIndex = historyEntries.findIndex((entry) => normalizeGuid(entry.id) === initialId);
                }

                if (initialIndex < 0) {
                    initialIndex = historyEntries.findIndex((entry) => entry.inUse);
                }

                if (initialIndex < 0) {
                    initialIndex = 0;
                }

                showHistoryEntry(initialIndex);
            };

            initializeHistory();

            if (historyPrevButton) {
                historyPrevButton.addEventListener('click', () => {
                    if (!Array.isArray(historyEntries) || historyEntries.length === 0) {
                        return;
                    }

                    const nextIndex = Math.min(historyIndex + 1, historyEntries.length - 1);
                    if (nextIndex !== historyIndex) {
                        showHistoryEntry(nextIndex);
                    }
                });
            }

            if (historyNextButton) {
                historyNextButton.addEventListener('click', () => {
                    if (!Array.isArray(historyEntries) || historyEntries.length === 0) {
                        return;
                    }

                    const nextIndex = Math.max(historyIndex - 1, 0);
                    if (nextIndex !== historyIndex) {
                        showHistoryEntry(nextIndex);
                    }
                });
            }

            const defaultSuccessMessage = 'We generated a new taste profile. Review and save it when you’re ready.';
            const defaultErrorMessage = 'We couldn’t generate a taste profile right now. Please try again.';
            const streamingStartMessage = 'Contacting the taste profile assistant…';

            const applyTasteProfilePayload = (payload) => {
                if (!payload || typeof payload !== 'object') {
                    return false;
                }

                let updated = false;

                if (typeof payload.summary === 'string') {
                    summaryField.value = payload.summary;
                    dispatchInputEvent(summaryField);
                    updated = true;
                }

                if (typeof payload.profile === 'string') {
                    profileField.value = payload.profile;
                    dispatchInputEvent(profileField);
                    updated = true;
                }

                if (Array.isArray(payload.suggestions)) {
                    updateSuggestions(payload.suggestions);
                }

                return updated;
            };

            const consumeNdjsonBuffer = (buffer, onEvent) => {
                if (typeof buffer !== 'string' || typeof onEvent !== 'function') {
                    return '';
                }

                let working = buffer;
                let newlineIndex = working.indexOf('\n');
                while (newlineIndex >= 0) {
                    const line = working.slice(0, newlineIndex).trim();
                    working = working.slice(newlineIndex + 1);
                    if (line) {
                        try {
                            const event = JSON.parse(line);
                            onEvent(event);
                        } catch (error) {
                            // Ignore malformed lines.
                        }
                    }

                    newlineIndex = working.indexOf('\n');
                }

                return working;
            };

            const processNdjsonText = (text, onEvent) => {
                if (typeof text !== 'string' || text.length === 0) {
                    return;
                }

                const normalized = text.endsWith('\n') ? text : `${text}\n`;
                consumeNdjsonBuffer(normalized, onEvent);
            };

            const readNdjsonStream = async (reader, onEvent) => {
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        if (value) {
                            buffer += decoder.decode(value, { stream: false });
                        } else {
                            buffer += decoder.decode();
                        }
                        break;
                    }

                    if (value) {
                        buffer += decoder.decode(value, { stream: true });
                        buffer = consumeNdjsonBuffer(buffer, onEvent);
                    }
                }

                if (buffer) {
                    processNdjsonText(buffer, onEvent);
                }
            };

            const handleTasteProfileEvent = (event, state) => {
                if (!event || typeof event !== 'object') {
                    return;
                }

                const type = typeof event.type === 'string' ? event.type : '';
                switch (type) {
                    case 'status': {
                        const statusMessage = typeof event.message === 'string'
                            ? event.message
                            : (typeof event.stage === 'string' ? event.stage : '');
                        if (statusMessage) {
                            setGeneratorMessage(null, statusMessage);
                        }
                        break;
                    }
                    case 'summary': {
                        if (typeof event.text === 'string') {
                            summaryField.value = event.text;
                            dispatchInputEvent(summaryField);
                        }
                        break;
                    }
                    case 'profile': {
                        if (typeof event.text === 'string') {
                            profileField.value = event.text;
                            dispatchInputEvent(profileField);
                        }
                        break;
                    }
                    case 'complete': {
                        state.completed = true;
                        const payload = event && typeof event.payload === 'object' ? event.payload : event;
                        applyTasteProfilePayload(payload);
                        focusEphemeralHistoryEntry(summaryField.value, profileField.value);
                        const successMessage = typeof event.message === 'string' && event.message.trim()
                            ? event.message
                            : defaultSuccessMessage;
                        setGeneratorMessage('success', successMessage);
                        break;
                    }
                    case 'error': {
                        state.error = true;
                        const errorMessage = typeof event.message === 'string' && event.message.trim()
                            ? event.message
                            : defaultErrorMessage;
                        setGeneratorMessage('error', errorMessage);
                        break;
                    }
                    default:
                        break;
                }
            };

            const extractErrorMessage = async (response, contentType) => {
                const normalizedType = contentType || '';
                if (normalizedType.includes('application/x-ndjson')) {
                    const text = await response.text().catch(() => '');
                    let extracted = null;
                    processNdjsonText(text, (event) => {
                        if (!extracted && event && typeof event === 'object' && typeof event.message === 'string') {
                            extracted = event.message.trim();
                        }
                    });
                    return extracted || defaultErrorMessage;
                }

                if (normalizedType.includes('application/json')) {
                    const payload = await response.json().catch(() => null);
                    if (payload && typeof payload.error === 'string' && payload.error.trim()) {
                        return payload.error.trim();
                    }
                    if (payload && typeof payload.message === 'string' && payload.message.trim()) {
                        return payload.message.trim();
                    }
                    return defaultErrorMessage;
                }

                const text = await response.text().catch(() => '');
                if (text) {
                    try {
                        const payload = JSON.parse(text);
                        if (payload && typeof payload.error === 'string' && payload.error.trim()) {
                            return payload.error.trim();
                        }
                    } catch (error) {
                        // Ignore parsing errors.
                    }
                }

                return defaultErrorMessage;
            };

            const readJsonPayload = async (response, contentType) => {
                const normalizedType = contentType || '';
                if (normalizedType.includes('application/json')) {
                    return await response.json().catch(() => null);
                }

                const text = await response.text().catch(() => '');
                if (!text) {
                    return null;
                }

                try {
                    return JSON.parse(text);
                } catch (error) {
                    return null;
                }
            };

            generatorButton.addEventListener('click', async () => {
                if (generatorButton.disabled) {
                    return;
                }

                setGeneratorMessage(null, streamingStartMessage);
                const originalLabel = (generatorButton.textContent || '').trim() || 'Generate profile';
                generatorButton.disabled = true;
                generatorButton.textContent = 'Generating…';

                const state = { completed: false, error: false };

                try {
                    const headers = {
                        'Content-Type': 'application/json',
                        Accept: 'application/x-ndjson, application/json'
                    };
                    const tokenValue = tokenInput ? tokenInput.value : null;
                    if (tokenValue) {
                        headers['RequestVerificationToken'] = tokenValue;
                    }

                    const suggestionBudgetValue = suggestionBudgetInput ? suggestionBudgetInput.value : '';
                    const suggestionBudget = suggestionBudgetValue && suggestionBudgetValue.trim() !== ''
                        ? Number.parseFloat(suggestionBudgetValue)
                        : null;

                    const response = await fetch(generatorUrl, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({
                            suggestionBudget: Number.isFinite(suggestionBudget) ? suggestionBudget : null
                        }),
                        credentials: 'same-origin'
                    });

                    const contentType = (response.headers.get('Content-Type') || '').toLowerCase();

                    if (!response.ok) {
                        const errorMessage = await extractErrorMessage(response, contentType);
                        state.error = true;
                        setGeneratorMessage('error', errorMessage);
                        return;
                    }

                    if (contentType.includes('application/x-ndjson')) {
                        const handleEvent = (event) => handleTasteProfileEvent(event, state);
                        const body = response.body;
                        const forceFallback = typeof window !== 'undefined' && window.__forceTasteProfileTextFallback === true;
                        if (!forceFallback && body && typeof body.getReader === 'function') {
                            await readNdjsonStream(body.getReader(), handleEvent);
                        } else {
                            const text = await response.text().catch(() => '');
                            processNdjsonText(text, handleEvent);
                        }
                    } else {
                        const payload = await readJsonPayload(response, contentType);
                        if (!payload) {
                            state.error = true;
                            setGeneratorMessage('error', defaultErrorMessage);
                            return;
                        }

                        applyTasteProfilePayload(payload);
                        focusEphemeralHistoryEntry(summaryField.value, profileField.value);
                        setGeneratorMessage('success', defaultSuccessMessage);
                        state.completed = true;
                    }
                } catch (error) {
                    if (!state.error) {
                        state.error = true;
                        setGeneratorMessage('error', defaultErrorMessage);
                    }
                } finally {
                    generatorButton.disabled = false;
                    generatorButton.textContent = originalLabel;
                    if (!state.completed && !state.error) {
                        setGeneratorMessage('error', defaultErrorMessage);
                    }
                }
            });
        })();
    </script>
    @await Html.PartialAsync("_WineSurferBottomNav", Context?.Request?.Path.Value)
</body>
</html>

